
// ОПЕРАТОРЫ
// Есть 7 типов операторов: арифметические, сравнения, логические, присваивания, (инк/дек)ремент, битовые, прочие



// АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ
// c = a + b - складывает 2 операнда
// c = a - b - вычитает второй операнд из первого
// c = a * b - перемножает 2 операнда
// c = a / b - делит первый операнд на второй
// c = a % b - делит первый операнд на второй по модулю (остаток от деления)
// ВАЖНО: если результат операции превышает допустимый диапазон типа, происходит переполнение
byte a = 255;
byte b = (byte)(a + 1); // Переполнение, b = 0
// Для контроля переполнения используется контекст checked
checked
{
    int max = int.MaxValue;
    int willOverflow = max + 1; // Выбросит исключение OverflowException
}



// ОПЕРАТОРЫ СРАВНЕНИЯ
// c = a == b - равно (true, если операнды равны)
// c = a != b - не равно (true, если операнды не равны)
// c = a > b  - больше (true, если первый операнд строго больше второго)
// c = a < b  - меньше (true, если первый операнд строго меньше второго)
// c = a >= b - больше или равно (true, если первый операнд больше или равен второму)
// c = a <= b - меньше или равно (true, если первый операнд меньше или равен второму)
// ВАЖНО: для ссылочных типов (кроме string) операторы == и != сравнивают ссылки, а не значения. Для сравнения содержимого .Equals()
object str1 = "hello";
object str2 = new string("hello".ToCharArray());
Console.WriteLine(str1 == str2);        // false
Console.WriteLine(str1.Equals(str2));   // true



// ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
// c = a & b  - логическое И (true, если оба операнда true)
// c = a && b - логическое И (true, если оба операнда true), ВАЖНО: если первый операнд false - даже не вычисляет второй
// c = a | b  - логическое ИЛИ (true, если хотя бы один операнд true)
// c = a || b - логическое ИЛИ (true, если хотя бы один операнд true), ВАЖНО: если первый операнд true - даже не вычисляет второй
// c = a ^ b  - логическое исключающее ИЛИ (true, если операнды имеют разное значение (один true, второй false))
// c = !a     - логическое НЕ (инвертирует значение операнда)
// ВАЖНО: операторы & и | при использовании с числовыми операндами работают как побитовые
int x = 3;            // 0011 в двоичной
int y = 5;            // 0101 в двоичной
int resAnd = x & y;   // 0001 в двоичной (1)
int resOr = x | y;    // 0111 в двоичной (7)



// ОПЕРАТОРЫ ПРИСВАИВАНИЯ
// int x = 5; - простое присваивание
// x += 5;    - сокращённая запись для арифметических операторов (x += 5 то же самое что и x = x + 5, и так для остальных операторов)
// x &= true; - аналогичная сокращённая запись для логических операторов (x &= true то же самое что и x = x & true, и так для остальных операторов)



// ИНКРЕМЕНТ/ДЕКРЕМЕНТ
// int x = 5;
// x++; - инкремент, увеличивает значение операнда на 1
// x--; - декремент, уменьшает значение операнда на 1
// ВАЖНОЕ: есть большая разница в префиксной и постфиксной формами записи
int x1 = 5;
int y1 = x1++; // Значение x1 присваивается y1, а затем x1 увеличивается на 1, т.е. x1 = 6, y1 = 5
int a1 = 5;
int b1 = --a1; // Значение a1 уменьшается на 1, а затем присваивается b1, т.е. a1 = 4, b1 = 4



// БИТОВЫЕ ОПЕРАТОРЫ
// c = a & b  - побитовое И (5 & 3 -> 0101 & 0011 = 0001 -> 1)
// c = a | b  - побитовое ИЛИ (5 | 3 -> 0101 | 0011 = 0111 -> 7)
// c = a ^ b  - побитовое исключающее ИЛИ (5 ^ 3 -> 0101 ^ 0011 = 0110 -> 6)
// c = ~a     - побитовое отрицание (~5 -> ~0101 = 1010 -> -6 (для 32-битного int))
// c = a << 1 - битовый сдвиг влево (5 << 1 -> 0101 << 1 = 1010 -> 10)
// c = a >> 1 - битовый сдвиг вправо (5 >> 1 -> 0101 >> 1 = 0010 -> 2)



// ПРОЧИЕ ОПЕРАТОРЫ
// string name = person?.Name;                    - условный null (?.) - выполняет доступ к члену если тот не null, иначе возвращает null
// string name = inputName ?? "Default";          - объединение null (??) - возвращает левый операнд если он не null, иначе возвращает правый операнд
// name ??= "Default";                            - присваивание объединения null (??=) - присваивает правый операнд левому, если левый операнд null
// Func<int, int> square = x => x * x;            - лямбда-оператор (=>) - используется для объявления лямбда-выражений
// if (obj is string s) {...}                     - проверка типа (is) - проверяет, совместим ли объект с данным типом, возвращает bool
// string s = obj as string;                      - приведение типа (as) - выполняет приведение типа (если приведение невозможно, возвращает null)
// string result = (a > b) ? "A wins" : "B wins"; - тернарный оператор (?:) - сокращённая запись if-else (если условие до ? истинно, то выполняется часть до :, иначе после :)



// ПЕРЕГРУЗКА ОПЕРАТОРОВ
public struct Vector2D
{
    public double X { get; }
    public double Y { get; }

    public Vector2D(double x, double y) { X = x; Y = y; }

    // Перегрузка бинарного оператора +
    public static Vector2D operator +(Vector2D a, Vector2D b)
    {
        return new Vector2D(a.X + b.X, a.Y + b.Y);
    }

    // Перегрузка унарного оператора -
    public static Vector2D operator -(Vector2D a)
    {
        return new Vector2D(-a.X, -a.Y);
    }

    // Перегрузка оператора сравнения == (обязательно нужно перегрузить и !=)
    public static bool operator ==(Vector2D a, Vector2D b)
    {
        return a.X == b.X && a.Y == b.Y;
    }
    public static bool operator !=(Vector2D a, Vector2D b) => !(a == b);
}
// Использование перегруженных операторов
Vector2D v1 = new Vector2D(1, 2);
Vector2D v2 = new Vector2D(3, 4);
Vector2D sum = v1 + v2;       // Работает! sum.X=4, sum.Y=6
Vector2D inverse = -v1;       // inverse.X=-1, inverse.Y=-2
bool areEqual = (v1 == v2);   // false